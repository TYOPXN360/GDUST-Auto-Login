# auth.ps1 - 完整版：基于 HAR 的门户登录（严格网卡获取 + 二次地址相对路径处理 + HTTP 连通性验证 + 前台防断联，只有在断网或重连时输出提示，Ctrl+C 可停止）
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# ---------------- 退出辅助函数：按任意键后退出 ----------------
function Exit-WithPrompt {
    param([int]$Code = 0)
    try {
        Write-Host "`n按任意键退出..." -ForegroundColor Yellow
        $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
    } catch {
        Read-Host "按回车键退出"
    }
    exit $Code
}

# ---------------- 配置（来自 HAR） ----------------
$authUrl1 = "http://8.135.34.165/lfradius/libs/portal/unify/portal.php/login/Panabit_login"
$authUrl2Default = "http://172.18.100.100:8010/cgi-bin/webauth/ajax_webauth"
$basip = "172.18.100.100"
$nasid = "1"
$successUrl = "http://8.135.34.165/lfradius/libs/portal/unify/portal.php/login/success/nastype/Panabit/basip/172.18.100.100/usrip/"
$failUrl = "http://8.135.34.165/lfradius/libs/portal/unify/portal.php/login/fail"
$checkUrlTemplate = "http://172.18.100.100:8010/cgi-bin/webauth/ajax_webauth?action=radius&ip={0}"

# 连通性检测（HTTP）
$connectivityUrl = "https://www.baidu.com/"
$httpTimeoutSec = 8
$extraHttpRetries = 3
$pollAttempts = 10
$pollIntervalSec = 1

# Watchdog 配置（前台模式） - 检测间隔
$watchdogIntervalSec = 10
$watchdogRecoveryRetries = 3

# 存储文件（与脚本同目录）
$storeFile = Join-Path (Split-Path -Path $MyInvocation.MyCommand.Definition -Parent) "zhanghao.json"

function Info($s){ Write-Host $s -ForegroundColor Cyan }
function OK($s){ Write-Host $s -ForegroundColor Green }
function Err($s){ Write-Host $s -ForegroundColor Red }

# ---------------- 严格获取无线网卡信息 ----------------
function Get-WlanInterfaceInfoStrict {
    $result = @{ Name = $null; IPv4 = $null; MAC = $null }
    try {
        $adapters = Get-NetAdapter -Physical -ErrorAction Stop
        $wlanAdapters = $adapters | Where-Object {
            ($_.InterfaceDescription -match 'Wireless|Wi-?Fi|WLAN|无线') -or ($_.InterfaceType -eq 71)
        }
    } catch {
        $wlanAdapters = @()
    }

    if ($wlanAdapters -and $wlanAdapters.Count -gt 0) {
        $adapter = $wlanAdapters | Where-Object { $_.Status -eq 'Up' } | Select-Object -First 1
        if (-not $adapter) { $adapter = $wlanAdapters | Select-Object -First 1 }
        $result.Name = $adapter.Name
        try {
            $ipEntry = Get-NetIPAddress -InterfaceIndex $adapter.ifIndex -AddressFamily IPv4 -ErrorAction Stop | Where-Object { $_.IPAddress } | Select-Object -First 1
            if ($ipEntry) { $result.IPv4 = $ipEntry.IPAddress }
        } catch {}
        try {
            $mac = ($adapter | Select-Object -ExpandProperty MacAddress)
            if ($mac) {
                $mac2 = ($mac -replace '-|:','') -replace '(.{2})', '$1:'
                $mac2 = $mac2.TrimEnd(':').ToLower()
                $result.MAC = $mac2
            }
        } catch {}
        return $result
    }

    try {
        $nics = Get-WmiObject -Class Win32_NetworkAdapter -ErrorAction Stop | Where-Object {
            ($_.NetEnabled -eq $true) -and ( ($_.Name -match 'Wireless') -or ($_.Name -match 'Wi-?Fi|WLAN|无线') -or ($_.AdapterTypeID -eq 9) )
        }
        if ($nics -and $nics.Count -gt 0) {
            $nic = $nics | Select-Object -First 1
            $result.Name = $nic.Name
            $macRaw = $nic.MACAddress
            if ($macRaw) { $result.MAC = $macRaw.ToLower() }
            $cfg = Get-WmiObject -Class Win32_NetworkAdapterConfiguration -ErrorAction Stop | Where-Object { $_.MACAddress -and ($_.MACAddress.ToLower() -eq $macRaw.ToLower()) } | Select-Object -First 1
            if ($cfg -and $cfg.IPAddress) {
                $ipv4 = $cfg.IPAddress | Where-Object { $_ -match '\.' } | Select-Object -First 1
                if ($ipv4) { $result.IPv4 = $ipv4 }
            }
            return $result
        }
    } catch {}

    return $result
}

# ---------------- HTTP 连通性检测（优先 Invoke-WebRequest，再尝试 curl.exe） ----------------
function Test-ExternalConnectivityHttp {
    param($url, $timeoutSec)
    try {
        $resp = Invoke-WebRequest -Uri $url -Method Get -UseBasicParsing -TimeoutSec $timeoutSec -ErrorAction Stop
        if ($resp.StatusCode -ge 200 -and $resp.StatusCode -lt 400) { return $true }
        if ($resp.Content -and $resp.Content.Length -gt 0) { return $true }
    } catch {}
    try {
        $curl = Get-Command curl.exe -ErrorAction SilentlyContinue
        if ($curl) {
            $out = & $curl.Source -sS --max-time $timeoutSec -I $url 2>$null
            if ($out -and $out -match 'HTTP/.*\s2[0-9][0-9]') { return $true }
            if ($out -and $out -match 'HTTP/.*\s3[0-9][0-9]') { return $true }
        }
    } catch {}
    return $false
}

# ---------------- 核心认证函数：Do-Auth ----------------
function Do-Auth {
    param($username, $password)

    Info "`n开始认证流程..."

    $winfo = Get-WlanInterfaceInfoStrict
    if (-not ($winfo.Name -and $winfo.IPv4 -and $winfo.MAC)) {
        Err "未能从无线网卡获取到完整的 IPv4 与 MAC，认证失败。"
        return $false
    }
    $usrip = $winfo.IPv4
    $usrmac = $winfo.MAC.ToLower()
    Info "检测到无线接口： $($winfo.Name)  IP=$usrip  MAC=$usrmac"

    Info "[1/2] 发送 Panabit_login 初始请求..."
    $headers1 = @{
        "User-Agent" = "Mozilla/5.0 (Windows NT 10.0; Win64; x64)"
        "Referer" = "http://8.135.34.165/"
        "Origin" = "http://8.135.34.165"
        "Content-Type" = "application/x-www-form-urlencoded"
    }
    $body1 = @{
        usrname = $username
        passwd = $password
        treaty = "on"
        nasid  = $nasid
        usrmac = $usrmac
        usrip  = $usrip
        basip  = $basip
        success = ($successUrl + $usrip)
        fail = $failUrl
        offline = "1"
        portal_version = ""
        portal_papchap = ""
    }

    try {
        $resp1 = Invoke-WebRequest -Uri $authUrl1 -Method Post -Body $body1 -Headers $headers1 -UseBasicParsing -TimeoutSec 30
    } catch {
        Err "第一步请求失败：$_"
        return $false
    }

    # --------- 解析二次验证地址（增强处理相对路径和已在线页面） ---------
    $auth2 = $null
    if ($resp1 -and $resp1.Content) {
        $content = $resp1.Content

        if ($content -match 'portal_useroffline' -or $content -match '已在线' -or $content -match 'online') {
            Info "您的账号已经在线，正执行踢线指令，请稍候..."
            $auth2 = $authUrl2Default
        } else {
            if ($content -match 'action=["'']([^"'']+)["'']') { $auth2 = $Matches[1] }
            else {
                $m = ($content -split '\s+' ) | Where-Object { $_ -match '/cgi-bin/webauth|/lfradius|/portal' } | Select-Object -First 1
                if ($m) { $auth2 = $m -replace '["'']','' }
            }

            if ($auth2) {
                if ($auth2.StartsWith('/')) {
                    try {
                        if ($resp1.BaseResponse -and $resp1.BaseResponse.ResponseUri) {
                            $base = $resp1.BaseResponse.ResponseUri.GetLeftPart('Authority')
                            $scheme = $resp1.BaseResponse.ResponseUri.Scheme
                            $auth2 = $scheme + "://" + $base + $auth2
                            Info "相对路径已解析为完整地址: $auth2"
                        } else {
                            Info "无法从响应获取基地址，使用默认内部 webauth 地址"
                            $auth2 = $authUrl2Default
                        }
                    } catch {
                        Info "相对路径解析失败，回退到默认内部 webauth 地址"
                        $auth2 = $authUrl2Default
                    }
                } elseif (-not ($auth2 -match '^https?://')) {
                    Info "提取到的二次地址不是完整 URL，使用默认内部 webauth 地址"
                    $auth2 = $authUrl2Default
                } else {
                    Info "解析到二次验证地址: $auth2"
                }
            } else {
                Info "未解析到二次地址，使用默认: $authUrl2Default"
                $auth2 = $authUrl2Default
            }
        }
    } else {
        Info "第一次响应无内容，使用默认内部 webauth 地址"
        $auth2 = $authUrl2Default
    }

    Info "[2/2] 向内部 webauth 提交核心登录请求..."
    $headers2 = $headers1
    $body2 = @{
        action = "login"
        user = $username
        pwd  = $password
        usrmac = $usrmac
        ip = $usrip
        success = ($successUrl + $usrip)
        fail = $failUrl
    }

    try {
        $resp2 = Invoke-WebRequest -Uri $auth2 -Method Post -Body $body2 -Headers $headers2 -UseBasicParsing -TimeoutSec 60
    } catch {
        Err "二次请求失败：$_"
        return $false
    }

    $checkUrl = [string]::Format($checkUrlTemplate, $usrip)
    Info "`n开始轮询 $checkUrl 检查登录结果（最多 $pollAttempts 次，每 $pollIntervalSec 秒）..."
    $loginRet0 = $false
    for ($i=0; $i -lt $pollAttempts; $i++) {
        Start-Sleep -Seconds $pollIntervalSec
        try {
            $r = Invoke-RestMethod -Uri $checkUrl -Method Post -UseBasicParsing -TimeoutSec 10 -ErrorAction Stop
            if ($null -ne $r) {
                if ($r.ret -eq 0) { Info "服务器返回 ret=0（登录成功指示）"; $loginRet0 = $true; break }
                elseif ($r.ret -eq 1) { Err "服务器返回 ret=1（登录失败），msg=$($r.msg)"; break }
                else { Info "尝试 $($i+1)：返回 ret=$($r.ret) msg=$($r.msg)" }
            } else { Info "尝试 $($i+1)：未返回有效 JSON" }
        } catch {
            try {
                $txt = (Invoke-WebRequest -Uri $checkUrl -Method Post -UseBasicParsing -TimeoutSec 10).Content
                if ($txt -match '"ret"\s*:\s*0') { Info "检测到文本中包含 ret=0"; $loginRet0 = $true; break }
            } catch {}
            Info "尝试 $($i+1)：查询请求无效或超时，继续..."
        }
    }

    if (-not $loginRet0) {
        Err "登录未获得 ret=0，认证失败或超时。"
        return $false
    }

    Info "`n开始外网连通性检测：HTTP GET $connectivityUrl (超时 ${httpTimeoutSec}s)..."
    $httpOk = Test-ExternalConnectivityHttp -url $connectivityUrl -timeoutSec $httpTimeoutSec
    if ($httpOk) {
        OK "HTTP 检测成功，认证及连通性确认通过。"
        return $true
    } else {
        Info "首次 HTTP 检测失败，进行最多 $extraHttpRetries 次额外重试，每次间隔 2 秒..."
        $attempt = 0
        while ($attempt -lt $extraHttpRetries -and -not $httpOk) {
            Start-Sleep -Seconds 2
            $attempt++
            Info "额外重试第 $attempt 次..."
            $httpOk = Test-ExternalConnectivityHttp -url $connectivityUrl -timeoutSec $httpTimeoutSec
        }
        if ($httpOk) {
            OK "HTTP 重试成功，认证及连通性确认通过。"
            return $true
        } else {
            Err "虽已获得认证指示（ret=0），但无法通过 HTTP 检测到 $connectivityUrl。"
            return $false
        }
    }
}

# ---------------- 前台 Watchdog 函数（只在断网或重连时输出提示，阻塞当前窗口，可 Ctrl+C 停止） ----------------
function Run-WatchdogForeground {
    param([string]$Username, [string]$Password)

    $wasOk = $true
    try {
        while ($true) {
            Start-Sleep -Seconds $watchdogIntervalSec
            $ok = Test-ExternalConnectivityHttp -url $connectivityUrl -timeoutSec $httpTimeoutSec
            if ($ok) {
                $wasOk = $true
                continue
            } else {
                if ($wasOk) {
                    # 仅在从正常变为异常的那一刻提示一次
                    Err "watchdog: 检测到外网不可达，开始尝试自动重连认证..."
                }
                $wasOk = $false
                $retries = 0
                $reconnected = $false
                while ($retries -lt $watchdogRecoveryRetries -and -not $reconnected) {
                    $retries++
                    Info "watchdog: 第 $retries 次尝试重新认证..."
                    try {
                        $res = Do-Auth -username $Username -password $Password
                        if ($res) {
                            OK "watchdog: 重连认证成功。"
                            $reconnected = $true
                            $wasOk = $true
                            break
                        } else {
                            Err "watchdog: 本次重连认证失败。"
                        }
                    } catch {
                        Err "watchdog: 重连执行异常：$_"
                    }
                    Start-Sleep -Seconds 2
                }
                if (-not $reconnected) {
                    Err "watchdog: 多次重连失败，等待下一轮检测。"
                }
            }
        }
    } catch [System.Management.Automation.PipelineStoppedException] {
        Info "`n收到中断信号 (Ctrl+C)，watchdog 将停止并退出。"
    } catch {
        Err "`nwatchdog 遇到异常：$_"
    } finally {
        Info "watchdog 已停止。"
    }
}

# ---------------- 参数解析：支持 -y/-n 及 username/password ----------------
$enableWatchdog = $null
for ($i = 0; $i -lt $args.Count; $i++) {
    if ($args[$i] -eq "-y") { $enableWatchdog = $true }
    elseif ($args[$i] -eq "-n") { $enableWatchdog = $false }
}
$cleanArgs = @()
for ($i = 0; $i -lt $args.Count; $i++) {
    if ($args[$i] -ne "-y" -and $args[$i] -ne "-n") { $cleanArgs += $args[$i] }
}
$userArg = $null; $passArg = $null
if ($cleanArgs.Count -ge 1) { $userArg = $cleanArgs[0] }
if ($cleanArgs.Count -ge 2) { $passArg = $cleanArgs[1] }

# 读取或交互输入账号密码
$username = $null; $password = $null
if ( (Test-Path $storeFile) -and (-not $userArg) ) {
    try {
        $json = Get-Content -Path $storeFile -Raw | ConvertFrom-Json
        if ($null -ne $json.username -and $null -ne $json.password) {
            $username = $json.username
            $password = $json.password
            Info "已从 zhanghao.json 读取账号"
        } else { throw "文件缺少字段" }
    } catch {
        Err "读取 zhanghao.json 失败或格式异常，将重新输入"
        Remove-Item -Path $storeFile -ErrorAction SilentlyContinue
    }
}

if (-not $username -and -not $userArg) {
    do { $username = Read-Host "请输入账号（用户名/手机号）" } while ([string]::IsNullOrWhiteSpace($username))
}
if ($userArg) { $username = $userArg; Info "使用命令行传入的账号" }

if (-not $password -and -not $passArg) {
    $secure = Read-Host -AsSecureString "请输入密码（输入不可见）"
    $password = [Runtime.InteropServices.Marshal]::PtrToStringAuto(
        [Runtime.InteropServices.Marshal]::SecureStringToBSTR($secure)
    )
}
if ($passArg) { $password = $passArg; Info "使用命令行传入的密码（隐藏显示）" }

# 首次保存（如果之前不存在）
if ( -not (Test-Path $storeFile) -and $username -and $password ) {
    @{ username = $username; password = $password } | ConvertTo-Json -Depth 3 | Out-File -FilePath $storeFile -Encoding UTF8
    OK "账号已保存到 zhanghao.json（请妥善保管）"
}

# ---------------- 主流程：执行一次认证 ----------------
$authOk = Do-Auth -username $username -password $password

if (-not $authOk) {
    Err "认证失败。脚本结束。"
    Exit-WithPrompt 3
}

# 认证成功后决定是否启动 watchdog（前台模式）
if ($enableWatchdog -eq $true) {
    Info "检测到命令行参数要求：自动启动 watchdog（前台运行）。"
    OK "watchdog 已启动（前台运行），按 Ctrl+C 可停止。"
    Run-WatchdogForeground -Username $username -Password $password
} elseif ($enableWatchdog -eq $false) {
    Info "检测到命令行参数要求：不启动 watchdog。"
} else {
    do {
        $ans = Read-Host "是否要启动防断联前台进程以保持认证状态？(y/n)"
        if ($ans -match '^[Yy]$') {
            OK "watchdog 已启动（前台运行），按 Ctrl+C 可停止。"
            Run-WatchdogForeground -Username $username -Password $password
            break
        } elseif ($ans -match '^[Nn]$') { Info "不启动 watchdog，脚本结束。"; break }
    } while ($true)
}

OK "`n主流程完成。"
Exit-WithPrompt 0
