# 广东科技学院(南城校区)校园网一键认证登录脚本
param(
    [switch]$y,  # 自动开启防断联
    [switch]$n   # 自动关闭防断联（与-y互斥）
)

Add-Type -AssemblyName System.Web

# --------------------------
# 工具函数1：按任意键退出
# --------------------------
function WaitForKeyAndExit {
    param([int]$ExitCode = 0)
    Write-Host "`n按任意键退出..." -ForegroundColor Cyan
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
    Exit $ExitCode
}

# --------------------------
# 工具函数2：参数冲突检查
# --------------------------
function Check-ParamConflict {
    if ($y -and $n) {
        Write-Host "?? 错误：-y和-n参数不能同时使用，请仅选择其中一个" -ForegroundColor Red
        WaitForKeyAndExit -ExitCode 1
    }
}

# --------------------------
# 工具函数3：读取/保存账号密码
# --------------------------
function Get-AccountInfo {
    # 初始化账号密码变量（首次运行需手动输入）
    $savedUsername = ""
    $savedPassword = ""

    # 若已保存账号密码，直接返回；否则强制提示输入
    if (-not [string]::IsNullOrWhiteSpace($savedUsername) -and -not [string]::IsNullOrWhiteSpace($savedPassword)) {
        return $savedUsername, $savedPassword
    }

    # 强制提示用户输入
    Write-Host "`n未检测到已保存的账号密码，请输入校园网认证信息" -ForegroundColor Cyan
    $username = Read-Host "请输入账号（通常为学号）"
    while ([string]::IsNullOrWhiteSpace($username)) {
        Write-Host "?? 账号不能为空！" -ForegroundColor Red
        $username = Read-Host "请重新输入账号"
    }

    $password = Read-Host "请输入密码" -AsSecureString
    $passwordPlain = [System.Net.NetworkCredential]::new("", $password).Password
    while ([string]::IsNullOrWhiteSpace($passwordPlain)) {
        Write-Host "?? 密码不能为空！" -ForegroundColor Red
        $password = Read-Host "请重新输入密码" -AsSecureString
        $passwordPlain = [System.Net.NetworkCredential]::new("", $password).Password
    }

    # 尝试自动保存账号密码
    try {
        $scriptPath = if (-not [string]::IsNullOrWhiteSpace($PSCommandPath)) { $PSCommandPath } else { $MyInvocation.MyCommand.Path }
        if (-not (Test-Path -Path $scriptPath -PathType Leaf)) {
            throw "脚本路径无效，无法自动保存"
        }

        $scriptContent = (Get-Content -Path $scriptPath) -join "`n"
        $updatedContent = $scriptContent -replace '(?m)^(\s*)\$savedUsername\s*=\s*""', "`$1`$savedUsername = `"$username`"" `
                                        -replace '(?m)^(\s*)\$savedPassword\s*=\s*""', "`$1`$savedPassword = `"$passwordPlain`""
        Set-Content -Path $scriptPath -Value $updatedContent -Force
        Write-Host "?? 账号密码已保存，下次运行无需重复输入" -ForegroundColor Green
    } catch {
        Write-Host "???? 警告：自动保存失败（可能无写入权限）" -ForegroundColor Yellow
        Write-Host "   错误原因：$_" -ForegroundColor Yellow
        Write-Host "   手动保存：修改脚本中`$savedUsername和`$savedPassword的值" -ForegroundColor Yellow
    }

    return $username, $passwordPlain
}

# --------------------------
# 工具函数4：提取服务器返回中文
# --------------------------
function Get-ChineseContent {
    param([string]$InputContent)
    $cleanContent = $InputContent -replace "<.*?>", "" `
        -replace '"微软雅黑"|"宋体"|"黑体|Helvetica|Arial|sans-serif', "" `
        -replace '""|,""|,"|[a-zA-Z0-9_./?&=;:+-]+', "" `
        -replace "\s+", " " `
        -replace '[^\u4e00-\u9fa5，。！；：""''（）【】、… ]', ""
    $cleanContent = $cleanContent.Trim()
    
    $chinesePattern = '([\u4e00-\u9fa5，。！；：""''（）【】、… ]{2,})'
    $chineseMatches = [regex]::Matches($cleanContent, $chinesePattern)
    $chineseContent = $chineseMatches | ForEach-Object { $_.Value.Trim() } | Where-Object { $_ -ne "" } | Select-Object -Unique
    return $chineseContent -join "；"
}

# --------------------------
# 工具函数5：核心认证流程（新增网卡名称检测）
# --------------------------
function Start-AuthFlow {
    param(
        [string]$Username,
        [string]$Password,
        [string]$Basip = "172.18.100.100",
        [bool]$IsReconnect = $false
    )

    # 步骤1：获取网卡信息（同时检测可修改的网卡名称和硬件描述）
    try {
        $adapter = Get-NetAdapter | Where-Object {
            # 匹配条件：
            # 1. 可修改的网卡名称（Name属性，用户可自定义）包含关键字
            # 2. 硬件描述（InterfaceDescription）包含关键字
            # 3. 排除虚拟网卡（Hyper-V/vEthernet）
            # 4. 网卡状态为启用（Up）
            (
                $_.Name -match "Wi-Fi|以太网|无线|有线|Fast|connect|网络" -or  # 可修改的名称关键字
                $_.InterfaceDescription -match "WLAN|Wi-Fi|Ethernet|Fast|connect"  # 硬件描述关键字
            ) -and
            $_.InterfaceDescription -notmatch "Hyper-V|vEthernet" -and  # 排除虚拟网卡
            $_.Status -eq "Up"  # 网卡必须启用
        } | ForEach-Object {
            # 获取IPv4地址（忽略无IP的网卡）
            $ipv4Addr = $_ | Get-NetIPAddress -AddressFamily IPv4 -ErrorAction SilentlyContinue
            if ($ipv4Addr) {
                $_ | Add-Member -NotePropertyName "IPv4Address" -NotePropertyValue $ipv4Addr.IPAddress -PassThru
            }
        } | Select-Object -First 1  # 优先选择第一个符合条件的网卡

        if (-not $adapter) {
            Write-Host "[错误] 未找到可用网卡！" -ForegroundColor Red
            Write-Host "   请确保存在启用的网卡，且名称（可修改）或硬件描述包含以下关键字：" -ForegroundColor Red
            Write-Host "   名称关键字：Wi-Fi、以太网、无线、有线、Fast、connect、网络" -ForegroundColor Red
            Write-Host "   硬件描述关键字：WLAN、Wi-Fi、Ethernet、Fast、connect" -ForegroundColor Red
            Write-Host "   （需排除Hyper-V虚拟网卡和vEthernet虚拟交换机）" -ForegroundColor Red
            return $false, $null, $null
        }

        $wlanUserIp = $adapter.IPv4Address
        $clientMac = $adapter.MacAddress
        $timestamp = [Math]::Floor([decimal](Get-Date -UFormat %s))
        
        # 输出网卡信息（区分名称和硬件描述）
        if ($IsReconnect) {
            Write-Host "[重连-网卡信息] 名称：$($adapter.Name) | 硬件描述：$($adapter.InterfaceDescription) | IP：$wlanUserIp | MAC：$clientMac" -ForegroundColor Cyan
        } else {
            Write-Host "[首次认证-网卡信息] 名称：$($adapter.Name) | 硬件描述：$($adapter.InterfaceDescription) | IP：$wlanUserIp | MAC：$clientMac" -ForegroundColor Cyan
        }
    } catch {
        Write-Host "[错误] 获取网卡参数失败：$_" -ForegroundColor Red
        return $false, $null, $null
    }

    # 步骤2：初始认证（获取二次认证地址）
    $webSession = New-Object Microsoft.PowerShell.Commands.WebRequestSession
    $ajaxUrlFromForm = $null
    try {
        $mainUrl = "http://8.135.34.165/lfradius/libs/portal/unify/portal.php/login/main/nasid/1/?" +
            "wlanuserip=$wlanUserIp&wlanacname=gdkjxy&clientip=$wlanUserIp&clientmac=$clientMac&" +
            "paip=$Basip&vlan=3001.0&iarmdst=www.qq.com/?time=$timestamp"

        $postParams = @{
            usrname = $Username
            passwd = $Password
            treaty = "on"
            nasid = "1"
            usrmac = $clientMac
            usrip = $wlanUserIp
            basip = $Basip
            success = "http://8.135.34.165/lfradius/libs/portal/unify/portal.php/login/success"
            fail = "http://8.135.34.165/lfradius/libs/portal/unify/portal.php/login/fail"
        }

        # 构造POST请求体
        $encodedKeyValues = @()
        foreach ($key in $postParams.Keys) {
            $encodedValue = [System.Web.HttpUtility]::UrlEncode($postParams[$key])
            $encodedKeyValues += "$key=$encodedValue"
        }
        $encodedBody = $encodedKeyValues -join "&"

        # 发送初始认证请求
        if ($IsReconnect) {
            Write-Host "[重连-步骤1] 发送认证请求..." -ForegroundColor Cyan
        } else {
            Write-Host "[首次认证-步骤1] 发送初始认证请求..." -ForegroundColor Cyan
        }
        
        $response1 = Invoke-WebRequest -Uri "http://8.135.34.165/lfradius/libs/portal/unify/portal.php/login/Panabit_login" `
            -Method Post `
            -Body $encodedBody `
            -Headers @{ 
                Referer = $mainUrl 
                "User-Agent" = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/142.0.0.0" 
                "Content-Type" = "application/x-www-form-urlencoded"
            } `
            -WebSession $webSession `
            -TimeoutSec 30 `
            -ErrorAction Stop

        if ($response1.StatusCode -eq 200) {
            $serverContent1 = if ($response1.Content -is [byte[]]) {
                try { [System.Text.Encoding]::GetEncoding("gbk").GetString($response1.Content) }
                catch { [System.Text.Encoding]::UTF8.GetString($response1.Content) }
            } else { $response1.Content }

            $chineseTip1 = Get-ChineseContent -InputContent $serverContent1
            if ($chineseTip1) { 
                Write-Host "[服务器提示] $chineseTip1" -ForegroundColor Magenta
            }

            # 提取二次认证地址
            if ($serverContent1 -match '<form name="login" action="([^"]+)" method="post"') {
                $ajaxUrlFromForm = $matches[1]
                Write-Host "[认证地址] 提取到二次认证地址：$ajaxUrlFromForm" -ForegroundColor Cyan
            }
        } else {
            throw "认证请求失败，状态码：$($response1.StatusCode)"
        }
    } catch {
        Write-Host "[错误] 初始认证请求失败：$_" -ForegroundColor Red
        return $false, $null, $null
    }

    # 步骤3：二次认证（核心登录）
    try {
        $ajaxParams = @{
            action = "login"
            user = $Username
            pwd = $Password
            usrmac = $clientMac
            ip = $wlanUserIp
            success = $postParams.success
            fail = $postParams.fail
        }

        # 构造POST请求体
        $ajaxKeyValues = @()
        foreach ($key in $ajaxParams.Keys) {
            $encodedVal = [System.Web.HttpUtility]::UrlEncode($ajaxParams[$key])
            $ajaxKeyValues += "$key=$encodedVal"
        }
        $ajaxBody = $ajaxKeyValues -join "&"

        $ajaxUrl = if ($ajaxUrlFromForm) { $ajaxUrlFromForm } else { "http://172.18.100.100:8010/cgi-bin/webauth/ajax_webauth" }
        
        # 发送二次认证请求
        if ($IsReconnect) {
            Write-Host "[重连-步骤2] 发送登录请求到：$ajaxUrl" -ForegroundColor Cyan
        } else {
            Write-Host "[首次认证-步骤2] 发送二次认证请求到：$ajaxUrl" -ForegroundColor Cyan
        }
        
        $response2 = Invoke-WebRequest -Uri $ajaxUrl `
            -Method Post `
            -Body $ajaxBody `
            -Headers @{ 
                Referer = "http://8.135.34.165/" 
                Origin = "http://8.135.34.165" 
                "User-Agent" = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/142.0.0.0" 
                "Content-Type" = "application/x-www-form-urlencoded"
            } `
            -WebSession $webSession `
            -TimeoutSec 30 `
            -ErrorAction Stop

        $serverContent2 = if ($response2.Content -is [byte[]]) {
            try { [System.Text.Encoding]::GetEncoding("GB2312").GetString($response2.Content) }
            catch { [System.Text.Encoding]::UTF8.GetString($response2.Content) }
        } else { $response2.Content }

        $chineseTip2 = Get-ChineseContent -InputContent $serverContent2
        if ($chineseTip2) { 
            Write-Host "[服务器提示] $chineseTip2" -ForegroundColor Magenta
        }

        # 认证结果提示
        if ($IsReconnect) {
            Write-Host "[重连-结果] 二次认证流程完成" -ForegroundColor Green
        } else {
            Write-Host "[首次认证-结果] 二次认证流程完成" -ForegroundColor Green
        }
        return $true, $wlanUserIp, $clientMac
    } catch {
        Write-Host "[错误] 二次认证请求失败：$_" -ForegroundColor Red
        return $false, $null, $null
    }
}

# --------------------------
# 主流程：参数检查+账号密码获取+认证
# --------------------------
Check-ParamConflict

# 获取账号密码
$usrname, $passwordPlain = Get-AccountInfo

# 首次认证
$firstAuthSuccess, $userIp, $userMac = Start-AuthFlow -Username $usrname -Password $passwordPlain -IsReconnect $false
if (-not $firstAuthSuccess) {
    Write-Host "[最终结果] 首次认证失败，脚本退出" -ForegroundColor Red
    WaitForKeyAndExit -ExitCode 1
}

# 验证网络连通性
Write-Host "`n==================================================" -ForegroundColor Cyan
Write-Host "正在验证网络连通性（请求bing.com）..." -ForegroundColor Cyan
$curlSuccess = $false
$curlPath = "C:\Windows\System32\curl.exe"
$curlArgs = @("-I", "-m", "5", "-s", "-w", "%{http_code}", "https://bing.com")
try {
    $curlOutput = & $curlPath $curlArgs 2>&1
    if ($curlOutput -match '^(200|3\d{2})$') {
        Write-Host "?? 首次认证成功！网络已连通（HTTP状态码：$matches[0]）" -ForegroundColor Green
        Write-Host "?? 认证信息：" -ForegroundColor Cyan
        Write-Host "   账号：$usrname | IP：$userIp | MAC：$userMac" -ForegroundColor Cyan
        $curlSuccess = $true
    } else {
        $errorMsg = if ($curlOutput -is [Management.Automation.ErrorRecord]) { $curlOutput.Exception.Message } else { "HTTP状态码：$curlOutput" }
        Write-Host "?? 首次认证失败！网络未连通：$errorMsg" -ForegroundColor Red
    }
} catch {
    Write-Host "?? 连通性检测异常：$_" -ForegroundColor Red
}
Write-Host "==================================================" -ForegroundColor Cyan

# 首次连通失败则退出
if (-not $curlSuccess) {
    WaitForKeyAndExit -ExitCode 1
}

# --------------------------
# 防断联逻辑（持续重试机制）
# --------------------------
if ($y) {
    Write-Host "`n检测到参数-y，开启防断联模式（网络异常时每5秒重试，按Ctrl+C退出）" -ForegroundColor Green
    Write-Host "==================================================" -ForegroundColor Cyan
    $startAntiDisconnect = $true
} elseif ($n) {
    Write-Host "`n检测到参数-n，不开启防断联，脚本退出" -ForegroundColor Green
    $startAntiDisconnect = $false
} else {
    do {
        Write-Host "`n是否开启防断联模式？（网络异常时每5秒自动重试，按Ctrl+C退出）[Y/N]" -ForegroundColor Cyan
        $userInput = Read-Host "请输入 Y 或 N"
        $userInput = $userInput.Trim().ToUpper()
        if ($userInput -notin "Y", "N") {
            Write-Host "?? 输入无效！请仅输入 Y 或 N" -ForegroundColor Red
        }
    } while ($userInput -notin "Y", "N")
    
    if ($userInput -eq "Y") {
        $startAntiDisconnect = $true
        Write-Host "`n?? 已开启防断联模式（每5秒检测一次，网络异常时自动重试）" -ForegroundColor Green
        Write-Host "==================================================" -ForegroundColor Cyan
    } else {
        $startAntiDisconnect = $false
    }
}

# 防断联主循环（核心改进：持续重试）
if ($startAntiDisconnect) {
    while ($true) {
        Start-Sleep -Seconds 5  # 每5秒检测一次
        try {
            $curlOutputLoop = & $curlPath $curlArgs 2>&1
            # 网络正常则继续循环检测
            if ($curlOutputLoop -match '^(200|3\d{2})$') {
                continue
            }

            # 网络异常：开始重试流程
            Write-Host "`n==================================================" -ForegroundColor Red
            Write-Host "?? 网络连接异常！开始重试（每5秒一次）..." -ForegroundColor Red
            Write-Host "==================================================" -ForegroundColor Red

            # 重试逻辑：持续认证直到网络恢复
            do {
                $reconnectSuccess, $reconnectIp, $reconnectMac = Start-AuthFlow -Username $usrname -Password $passwordPlain -IsReconnect $true
                if (-not $reconnectSuccess) {
                    Write-Host "???? 本次认证失败，5秒后重试..." -ForegroundColor Yellow
                    Start-Sleep -Seconds 5
                    continue
                }

                # 认证成功后检测网络是否恢复
                $reconnectCurl = & $curlPath $curlArgs 2>&1
                if ($reconnectCurl -match '^(200|3\d{2})$') {
                    Write-Host "`n?? 重连成功！网络已恢复（HTTP状态码：$matches[0]）" -ForegroundColor Green
                    Write-Host "?? 当前信息：账号：$usrname | IP：$reconnectIp | MAC：$reconnectMac" -ForegroundColor Cyan
                    Write-Host "==================================================" -ForegroundColor Green
                    break  # 网络恢复，退出重试循环
                } else {
                    Write-Host "???? 认证成功但网络未恢复，5秒后重试..." -ForegroundColor Yellow
                    Start-Sleep -Seconds 5
                }
            } while ($true)  # 直到网络恢复才退出重试
        } catch {
            Write-Host "`n???? 防断联检测异常：$_，5秒后重试..." -ForegroundColor Yellow
            Start-Sleep -Seconds 5
        }
    }
} else {
    Write-Host "`n?? 脚本正常退出" -ForegroundColor Green
    WaitForKeyAndExit -ExitCode 0
}
